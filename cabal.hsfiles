Up to date
{-# START_FILE .ghci #-}
:set prompt "> "
:set -fobject-code
-- overloaded strings can be a bother in the repl
:seti -XNoOverloadedStrings
-- -w turns warnings off
:seti -Wall
{-# START_FILE LICENSE #-}
Copyright (c) 2019,2020,2023 {{author}}

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject
to the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
{-# START_FILE app/Main.hs #-}
{-# LANGUAGE LambdaCase #-}

module Main where

import Data.Text.Lazy qualified as LT
import System.Directory (getCurrentDirectory)
import System.FilePath (takeFileName)
import Templation.Cmd
import Templation.Hsfiles qualified as Hsfiles

main :: IO ()
main =
  parseArgs >>= \case
    Hsfiles {username, email, project, output, verbose} -> do
      p <-
        if project == "."
          then getCurrentDirectory
          else return project
      let name = takeFileName p

      Hsfiles.makeTemplate
        Hsfiles.Config
          { Hsfiles.username = LT.pack username,
            Hsfiles.email = LT.pack email,
            Hsfiles.project = p,
            Hsfiles.output = output,
            Hsfiles.name = LT.pack name,
            Hsfiles.verbose
          }
    i@Init {} ->
      -- will not be parsed, the mode is deactivated
      print i
{-# START_FILE src/Templation/Cmd.hs #-}
{-# LANGUAGE DuplicateRecordFields #-}
-- disable cse because it breaks implict cmdargs
{-# OPTIONS_GHC -fno-cse #-}

-- | Cmd Line Parser
--
-- Implicit CmdArgs is much shorter than explicit, but it has a few quirks.
--
-- First, disable CSE.  Second, no nested records with shared sub-records -
-- they get called twice and the help texts get doubled.
module Templation.Cmd
  ( Op (..),
    parseArgs,
  )
where

import Data.Functor ((<&>))
import Data.Maybe (fromMaybe)
import System.Console.CmdArgs.Implicit
  ( CmdArgs,
    Data,
    Mode,
    Typeable,
    cmdArgsMode,
    cmdArgsRun,
    help,
    modes,
    opt,
    program,
    summary,
    typ,
    (&=),
  )
import System.Directory (getCurrentDirectory)
import System.Environment (lookupEnv)
import Templation.Git (gitConfig)

-- would have to use gibhub api (with api key)
-- to list *.hsfiles in a repo
data Op
  = Init
      { template :: String,
        repo :: String,
        username :: String,
        email :: String,
        project :: FilePath,
        verbose :: Bool
      }
  | Hsfiles
      { output :: FilePath,
        username :: String,
        email :: String,
        project :: FilePath,
        verbose :: Bool
      }
  deriving (Show, Eq, Data, Typeable)

data Defaults = Defaults
  { repo :: String,
    username :: String,
    email :: String,
    project :: FilePath
  }
  deriving (Show, Eq)

defaults :: IO Defaults
defaults = do
  repo <- lookupEnv "REPO" <&> fromMaybe "grmble/stack-templates"
  username <- gitConfig "user.name"
  email <- gitConfig "user.email"
  project <- getCurrentDirectory
  return $ Defaults {repo, username, email, project}

initOp :: Defaults -> Op
initOp Defaults {repo, username, email, project} =
  Init
    { template = "default" &= typ "FILE" &= opt "default" &= help "Template .hsfile in repo",
      repo =
        repo
          &= typ "REPO"
          &= help "Repo as in grmble/stack_templates or full github url, default: $TEMPLATION_REPO",
      username = username &= typ "USER" &= help "Username for author fields, default from git config",
      email = email &= typ "EMAIL" &= help "Email for email fields, default from git config",
      project = project &= typ "DIR" &= help "project directory",
      verbose = False &= help "Verbose output"
    }
    &= help "Initialize a project from the given template"

mkHsfilesOp :: Defaults -> Op
mkHsfilesOp Defaults {username, email, project} =
  Hsfiles
    { output = "" &= typ "FILE" &= help "Output .hsfile (default: standard out)",
      username = username &= typ "USER" &= help "Username for author fields, default from git config",
      email = email &= typ "EMAIL" &= help "Email for email fields, default from git config",
      project = project &= typ "DIR" &= help "project directory",
      verbose = False &= help "Verbose output"
    }
    &= help "Make a template from a project"

mode :: IO (Mode (CmdArgs Op))
mode = do
  d <- defaults
  return $
    cmdArgsMode $
      modes [{- initOp d, -} mkHsfilesOp d]
        &= help "Init projects and make hsfiles"
        &= program "{{name}}"
        &= summary "{{name}} v0.2"

parseArgs :: IO Op
parseArgs =
  mode
    >>= cmdArgsRun
{-# START_FILE src/Templation/Git.hs #-}
-- | Read Git Config
-- |
-- | Needs its own module without OverloadedStrings
module Templation.Git
  ( gitConfig,
  )
where

import Data.Functor ((<&>))
import Development.Shake.Command
  ( StdoutTrim (fromStdoutTrim),
    cmd,
  )

gitConfig :: String -> IO String
gitConfig cn =
  cmd "git" ["config", "--get", cn]
    <&> fromStdoutTrim
{-# START_FILE src/Templation/Hsfiles.hs #-}
{-# LANGUAGE OverloadedStrings #-}

-- | Create a Stack Template
--
-- The format is not really explained anywhere,
-- but it's basically a list of mustache templates
-- wrapped in School of Haskell Markdown Multi-File syntax.
--
-- https://www.schoolofhaskell.com/school/how-to-use-the-school-of-haskell/soh-markdown#multi-file-snippets
module Templation.Hsfiles
  ( Config (..),
    makeTemplate,
  )
where

import Control.Monad (foldM)
import Data.ByteString.Lazy qualified as LB
import Data.Foldable ()
import Data.Function ((&))
import Data.List (sort)
import Data.Text.Lazy qualified as LT
import Data.Text.Lazy.Builder qualified as LT
import Data.Text.Lazy.Encoding qualified as LT
import Data.Text.Lazy.IO qualified as LT
import System.Directory (listDirectory)
import System.FilePath (isExtensionOf, makeRelative)
import System.PosixCompat (getFileStatus, isDirectory)

-- | Recursively list all relevant files
--
-- Directories like @.git@, @.stack-work@ or @dist-newstyle@ are skipped.
-- Ideally, we would parse .gitignore Files as well
listFiles :: FilePath -> IO [FilePath]
listFiles prefixPath = go [] prefixPath
  where
    go :: [FilePath] -> FilePath -> IO [FilePath]
    go acc p = do
      entries <- listDirectory p
      entries
        & foldM prependPath acc
          . fmap (combinePath p)
          . filter (not . (`elem` [".git", ".stack-work", "dist-newstyle", "stack.yaml.lock"]))
          . filter (not . ("hsfiles" `isExtensionOf`))
        & fmap (fmap (makeRelative prefixPath))

    prependPath :: [FilePath] -> FilePath -> IO [FilePath]
    prependPath acc p = do
      st <- getFileStatus p
      if isDirectory st
        then go acc p
        else pure (p : acc)

-- | Combine 2 filepaths
--
-- >>> combinePath "a" "b"
-- "a/b"
-- >>> combinePath "" "b"
-- "b"
-- >>> combinePath "." "b"
-- "b"
combinePath :: FilePath -> FilePath -> FilePath
combinePath "" p2 = p2
combinePath "." p2 = p2
combinePath p1 p2 = p1 <> "/" <> p2

readSourceFile :: Config -> FilePath -> IO LT.Builder
readSourceFile cfg p = startFile . LT.decodeUtf8 <$> LB.readFile p
  where
    startFile bs =
      LT.fromLazyText "{-# START_FILE "
        <> LT.fromLazyText (processContent cfg (LT.pack p))
        <> " #-}\n"
        <> ensureLinefeedAtEnd (processContent cfg bs)

combineSourceFiles :: Config -> LT.Builder -> FilePath -> IO LT.Builder
combineSourceFiles cfg b p = (b <>) <$> readSourceFile cfg p

makeHSFile :: Config -> IO LT.Builder
makeHSFile cfg =
  listFiles (project cfg)
    >>= foldM (combineSourceFiles cfg) (LT.fromLazyText LT.empty) . sort

processContent :: Config -> LT.Text -> LT.Text
processContent Config {name, username, email} txt =
  txt
    & LT.splitOn name
    & LT.intercalate "{{name}}"
    & LT.splitOn username
    & LT.intercalate "{{author}}"
    & LT.splitOn email
    & LT.intercalate "{{email}}"
    & LT.splitOn "\r" -- remove carriage returns
    & LT.intercalate ""

ensureLinefeedAtEnd :: LT.Text -> LT.Builder
ensureLinefeedAtEnd bs =
  if LT.isSuffixOf "\n" bs
    then LT.fromLazyText bs
    else LT.fromLazyText bs <> "\n"

data Config = Config
  { project :: FilePath,
    name :: LT.Text,
    username :: LT.Text,
    email :: LT.Text,
    output :: FilePath,
    verbose :: Bool
  }
  deriving (Show)

makeTemplate :: Config -> IO ()
makeTemplate cfg =
  makeHSFile cfg
    >>= writeOutput (output cfg)
  where
    writeOutput "" = LT.putStr . LT.toLazyText
    writeOutput fn = LT.writeFile fn . LT.toLazyText
{-# START_FILE {{name}}.cabal #-}
cabal-version:  3.6
name:           {{name}}
version:        0.2.0.0
description:    Create and modify stack templates
homepage:       https://github.com/grmble/stack-templates#readme
bug-reports:    https://github.com/grmble/stack-templates/issues
author:         {{author}}
maintainer:     {{email}}
copyright:      (c) 2019,2020,2023 {{author}}
license:        MIT
license-file:   LICENSE
build-type:     Simple

source-repository head
  type: git
  location: https://github.com/grmble/stack-templates

common deps
  build-depends:
    , base >=4.16.4 && <5
    , bytestring
    , cmdargs
    , directory
    , filepath
    , shake
    , text
    , unix-compat
  default-language: GHC2021
  ghc-options: -O -Wall -Wcompat -Wincomplete-record-updates -Wincomplete-uni-patterns -Wredundant-constraints

library
  import: deps
  exposed-modules: 
    Templation.Cmd
    Templation.Git
    Templation.Hsfiles
  hs-source-dirs: 
    src

executable {{name}}
  import: deps
  main-is: Main.hs
  hs-source-dirs: 
    app
  ghc-options: -threaded -rtsopts -with-rtsopts=-N -with-rtsopts=-T
  build-depends:
    , {{name}}
